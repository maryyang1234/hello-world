# hello-world
1.在一个数组中找到总数为0的最大子数组，最直观的做法就是两层循环，外层i从0开始到数组的最后一位，内层循环计算当前i到最后一位的总和，并记录当前总和的长度，判断总和是否为0以及最大子数组的长度是否能够更新，时间复杂度为o（n^2）；


2.上题hash做法，初始化两个变量，一个是记录从数组0位到当前位的总和curr_sum（初始值为0），一个是随着curr_sum记录到当前位的最大子数组长度max_len（初始值为0）,如何更新max_len，如果数组有任何值为0且max_len仍然为0，则将max_len更新为1，以及若当前累加和为0，则将max_len更新为当前累加和的长度，其次判断当前累加和是否在hash表中，若不存在，则将这个累加和加到hash表中，并将其对应的key值设置为当前累加和的长度，若存在，则将当前累加和的长度减去hash表中对应的key值，这一段长度中的累加和是为0的，将这个长度与max_len做对比，若更大，则更新max_len


3.在一个数组中找到sum和最大的子数组，两个方法，前一个只求出最大值，后一个输出最大值并输出最大值的数组索引；后一个首先是两个变量，一个记录到数组第i位的的子数组的最大值max_ending_here，一个是更新记录整个数组的最大值max_so_far，以及两个索引值的初始值0，从0开始循环计算，首先判断max_ending_here是否小于0，小于0说明前一个数组值是小于0，或者说绝对值是比前一个数组值之前的max_ending_here还要大的负数，也就是说最大子数组不应该计算这个数，所以这时将max_ending_here置为0，并记录这个i值，将其作为最大sum和的前索引，然后将max_ending_here加上当前位的数组值（判断max_ending_here时不小于0也），然后将max_ending_here与max_so_far比较，更新max_so_far值，并记录sum和最大的后索引


4.类似于上题求sum和最大的思路

5.看注释
